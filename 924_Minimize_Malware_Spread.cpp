class Solution {
public:
    int find(int node) {
        int root = d_r[node];
        while (root != d_r[root]) {
            root = d_r[root];
        }
        while (node != root) {
            int p = d_r[node];
            d_r[node] = root;
            node = p;
        }
        return root;
    }
    
    void u(int a, int b) {
        int ra = find(a);
        int rb = find(b);
        if (ra != rb) {
            d_r[ra] = rb;
            d_s[rb] += d_s[ra];
        }
    }
    
    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        for (int i = 0; i < graph.size(); ++i) {
            d_r.push_back(i);
        }
        d_s = vector<int>(graph.size(), 1);
        d_i = vector<int>(graph.size(), 1);
        for (int i = 0; i < graph.size(); ++i) {
            for (int j = 0; j < graph[i].size(); ++j) {
                if (1 == graph[i][j]) {
                    u(i, j);
                }
            }
        }
        unordered_map<int, vector<int>> infected;
        for (const auto n:initial) {
            infected[find(n)].push_back(n);
        }
        unordered_map<int, int> counts;
        int max_i = 0;
        int result = initial[0];
        for (unordered_map<int, vector<int>>::iterator it = infected.begin(); it != infected.end(); ++it) {
            if (it->second.size() > 1) {
                for (int i = 0; i < it->second.size(); ++i) {
                    if (max_i < d_i[it->second[i]]) {
                        max_i = d_i[it->second[i]];
                        result = it->second[i];
                    } else if (max_i == d_i[it->second[i]]) {
                        result = min(result, it->second[i]);
                    }
                }
                continue;
            }
            d_i[it->second[0]] += d_s[it->first]-1;
            if (max_i < d_i[it->second[0]]) {
                max_i = d_i[it->second[0]];
                result = it->second[0];
            } else if (max_i == d_i[it->second[0]]) {
                result = min(result, it->second[0]);
            }
        }
        return result;
    }
private:
    vector<int> d_r;
    vector<int> d_s;
    vector<int> d_i;
};
